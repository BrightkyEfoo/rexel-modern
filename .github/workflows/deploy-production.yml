name: Deploy Frontend to Production

on:
  push:
    branches: [ main, master ]
      
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging
      rebuild_cache:
        description: 'Rebuild Next.js cache'
        required: true
        default: 'false'
        type: choice
        options:
          - 'true'
          - 'false'

env:
  DOCKER_IMAGE_NAME: rexel-frontend-prod
  VPS_DEPLOY_PATH: ~/rexel-modern/frontend
  CONTAINER_NAME: rexel-frontend-prod
  CONTAINER_PORT: 3000
  CADDY_CONTAINER_NAME: rexel-frontend-caddy-prod

jobs:
  prepare-directory:
    name: Prepare VPS Directory
    runs-on: ubuntu-latest
    environment: production
    steps:
      - name: Create deployment directory on VPS
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_PRIVATE_KEY }}
          port: 22
          script: |
            mkdir -p ${{ env.VPS_DEPLOY_PATH }}
            mkdir -p ${{ env.VPS_DEPLOY_PATH }}/backups
            mkdir -p ${{ env.VPS_DEPLOY_PATH }}/images
            mkdir -p ${{ env.VPS_DEPLOY_PATH }}/data
            mkdir -p ${{ env.VPS_DEPLOY_PATH }}/logs
            chmod 755 ${{ env.VPS_DEPLOY_PATH }}/logs
            chmod 755 ${{ env.VPS_DEPLOY_PATH }}/data

  docker-setup:
    name: Verify Docker Setup
    runs-on: ubuntu-latest
    environment: production
    steps:
      - name: Verify and setup Docker environment
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_PRIVATE_KEY }}
          port: 22
          script: |
            echo "=== Docker Environment Check ==="
            
            # Check if Docker is installed
            if ! command -v docker &> /dev/null; then
              echo "ðŸ”§ Docker not found, installing..."
              curl -fsSL https://get.docker.com -o get-docker.sh
              sudo sh get-docker.sh
              rm get-docker.sh
            else
              echo "âœ… Docker is installed: $(docker --version)"
            fi
            
            # Check if Docker service is running
            if ! sudo systemctl is-active --quiet docker; then
              echo "ðŸ”§ Starting Docker service..."
              sudo systemctl start docker
              sudo systemctl enable docker
            else
              echo "âœ… Docker service is running"
            fi
            
            # Check if user is in docker group
            if ! groups $USER | grep -q '\bdocker\b'; then
              echo "ðŸ”§ Adding user to docker group..."
              sudo usermod -aG docker $USER
              echo "âš ï¸  User added to docker group. Testing access..."
            else
              echo "âœ… User is in docker group"
            fi
            
            # Test Docker access with retry logic
            echo "ðŸ§ª Testing Docker access..."
            max_attempts=5
            attempt=1
            
            while [ $attempt -le $max_attempts ]; do
              if docker ps &> /dev/null; then
                echo "âœ… Docker access test successful!"
                break
              else
                echo "âš ï¸  Docker access test failed (attempt $attempt/$max_attempts)"
                if [ $attempt -eq $max_attempts ]; then
                  echo "âŒ Docker access still failing after $max_attempts attempts"
                  echo "Trying with sudo as fallback..."
                  if sudo docker ps &> /dev/null; then
                    echo "âœ… Docker works with sudo"
                    echo "âš ï¸  Will use sudo for Docker commands"
                  else
                    echo "âŒ Docker not working even with sudo"
                    exit 1
                  fi
                else
                  echo "Waiting 5 seconds before retry..."
                  sleep 5
                  # Try to refresh group membership
                  newgrp docker || true
                fi
              fi
              attempt=$((attempt + 1))
            done
            
            # Install Docker Compose if not present
            if ! command -v docker-compose &> /dev/null && ! docker compose version &> /dev/null; then
              echo "ðŸ”§ Installing Docker Compose..."
              sudo curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
              sudo chmod +x /usr/local/bin/docker-compose
            else
              echo "âœ… Docker Compose is available"
            fi
            
            # Final verification
            echo "=== Final Docker Environment Status ==="
            docker --version || sudo docker --version
            docker compose version || docker-compose --version || sudo docker compose version
            echo "Docker daemon status: $(sudo systemctl is-active docker)"
            echo "User groups: $(groups $USER)"

  checkout:
    name: Checkout Code
    runs-on: ubuntu-latest
    needs: [docker-setup, prepare-directory]
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Upload source code
        uses: actions/upload-artifact@v4
        with:
          name: source-code
          path: .
          retention-days: 1

  build-docker:
    name: Build Docker Image
    runs-on: ubuntu-latest
    environment: production
    needs: [checkout]
    steps:
      - name: Download source code
        uses: actions/download-artifact@v4
        with:
          name: source-code
      
      - name: Create production .env file
        run: |
          cat > .env.production << EOF
          # ===== GENERAL CONFIGURATION =====
          NODE_ENV=production
          NEXT_TELEMETRY_DISABLED=1
          
          # ===== APPLICATION =====
          NEXT_PUBLIC_APP_NAME="${{ secrets.NEXT_PUBLIC_APP_NAME }}"
          NEXT_PUBLIC_APP_VERSION="${{ secrets.NEXT_PUBLIC_APP_VERSION }}"
          
          # ===== DOMAINS & URLs =====
          FRONTEND_DOMAIN=${{ secrets.FRONTEND_DOMAIN }}
          NEXT_PUBLIC_API_URL=${{ secrets.NEXT_PUBLIC_API_URL }}
          NEXTAUTH_URL=${{ secrets.NEXTAUTH_URL }}
          
          # ===== SECURITY =====
          NEXTAUTH_SECRET=${{ secrets.NEXTAUTH_SECRET }}
          
          # ===== SSL/TLS =====
          ACME_EMAIL=${{ secrets.ACME_EMAIL }}
          
          # ===== API CONFIGURATION =====
          NEXT_PUBLIC_API_VERSION=${{ secrets.NEXT_PUBLIC_API_VERSION }}
          
          # ===== ANALYTICS & MONITORING =====
          NEXT_PUBLIC_ANALYTICS_ID=${{ secrets.NEXT_PUBLIC_ANALYTICS_ID }}
          NEXT_PUBLIC_GTM_ID=${{ secrets.NEXT_PUBLIC_GTM_ID }}
          NEXT_PUBLIC_SENTRY_DSN=${{ secrets.NEXT_PUBLIC_SENTRY_DSN }}
          
          # ===== FEATURES FLAGS =====
          NEXT_PUBLIC_ENABLE_FEATURES=${{ secrets.NEXT_PUBLIC_ENABLE_FEATURES }}
          
          # ===== CDN & ASSETS =====
          NEXT_PUBLIC_CDN_URL=${{ secrets.NEXT_PUBLIC_CDN_URL }}
          NEXT_PUBLIC_ASSETS_URL=${{ secrets.NEXT_PUBLIC_ASSETS_URL }}
          
          # ===== SOCIAL AUTH (Optional) =====
          GITHUB_CLIENT_ID=${{ secrets.GITHUB_CLIENT_ID }}
          GITHUB_CLIENT_SECRET=${{ secrets.GITHUB_CLIENT_SECRET }}
          GOOGLE_CLIENT_ID=${{ secrets.GOOGLE_CLIENT_ID }}
          GOOGLE_CLIENT_SECRET=${{ secrets.GOOGLE_CLIENT_SECRET }}
          
          # ===== PAYMENT (Optional) =====
          NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY=${{ secrets.NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY }}
          STRIPE_SECRET_KEY=${{ secrets.STRIPE_SECRET_KEY }}
          
          # ===== EMAIL (Optional) =====
          SMTP_HOST=${{ secrets.SMTP_HOST }}
          SMTP_PORT=${{ secrets.SMTP_PORT }}
          SMTP_USER=${{ secrets.SMTP_USER }}
          SMTP_PASSWORD=${{ secrets.SMTP_PASSWORD }}
          SMTP_FROM=${{ secrets.SMTP_FROM }}
          
          # ===== REDIS (Optional for caching) =====
          REDIS_URL=${{ secrets.REDIS_URL }}
          
          # ===== FEATURE FLAGS =====
          NEXT_PUBLIC_ENABLE_PWA=${{ secrets.NEXT_PUBLIC_ENABLE_PWA }}
          NEXT_PUBLIC_ENABLE_OFFLINE=${{ secrets.NEXT_PUBLIC_ENABLE_OFFLINE }}
          NEXT_PUBLIC_ENABLE_DARK_MODE=${{ secrets.NEXT_PUBLIC_ENABLE_DARK_MODE }}
          
          # ===== SEO & METADATA =====
          NEXT_PUBLIC_SITE_URL=${{ secrets.NEXT_PUBLIC_SITE_URL }}
          NEXT_PUBLIC_SITE_NAME="${{ secrets.NEXT_PUBLIC_SITE_NAME }}"
          NEXT_PUBLIC_SITE_DESCRIPTION="${{ secrets.NEXT_PUBLIC_SITE_DESCRIPTION }}"
          NEXT_PUBLIC_DEFAULT_LOCALE=${{ secrets.NEXT_PUBLIC_DEFAULT_LOCALE }}
          EOF
      
      - name: Verify .env file created
        run: |
          echo "Checking if .env.production file exists..."
          ls -la .env.production
          echo "Environment variables count:"
          wc -l .env.production
      
      - name: Generate image tag
        id: tag
        run: |
          SHORT_SHA=$(echo ${{ github.sha }} | cut -c1-7)
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          IMAGE_TAG="${{ env.DOCKER_IMAGE_NAME }}:${SHORT_SHA}-${TIMESTAMP}"
          echo "image-tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "short-sha=${SHORT_SHA}" >> $GITHUB_OUTPUT
          echo "timestamp=${TIMESTAMP}" >> $GITHUB_OUTPUT
      
      - name: Build Docker image
        run: |
          docker build -t ${{ steps.tag.outputs.image-tag }} .
          docker tag ${{ steps.tag.outputs.image-tag }} ${{ env.DOCKER_IMAGE_NAME }}:latest
      
      - name: Save Docker image to tar
        run: |
          docker save ${{ steps.tag.outputs.image-tag }} > rexel-frontend-prod.tar
          ls -lh rexel-frontend-prod.tar

      - name: Upload Docker image and compose file
        uses: actions/upload-artifact@v4
        with:
          name: docker-image-prod
          path: |
            rexel-frontend-prod.tar
            docker-compose.prod.yml
            Caddyfile
          retention-days: 7

  transfer-image:
    name: Transfer Image to VPS
    runs-on: ubuntu-latest
    environment: production
    needs: [prepare-directory, build-docker]
    steps:
      - name: Download Docker image
        uses: actions/download-artifact@v4
        with:
          name: docker-image-prod
      
      - name: Transfer Docker image and compose files to VPS
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_PRIVATE_KEY }}
          port: 22
          source: "rexel-frontend-prod.tar,docker-compose.prod.yml,Caddyfile"
          target: ${{ env.VPS_DEPLOY_PATH }}/
      
      - name: Create backup and organize files
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_PRIVATE_KEY }}
          port: 22
          script: |
            # Create images directory if it doesn't exist
            mkdir -p ${{ env.VPS_DEPLOY_PATH }}/images
            
            # Backup previous image if exists
            if [ -f ${{ env.VPS_DEPLOY_PATH }}/images/rexel-frontend-prod-current.tar ]; then
              mv ${{ env.VPS_DEPLOY_PATH }}/images/rexel-frontend-prod-current.tar ${{ env.VPS_DEPLOY_PATH }}/backups/rexel-frontend-prod-backup-$(date +%Y%m%d-%H%M%S).tar
            fi
            
            # Move new image to images directory
            mv ${{ env.VPS_DEPLOY_PATH }}/rexel-frontend-prod.tar ${{ env.VPS_DEPLOY_PATH }}/images/rexel-frontend-prod-current.tar
            
            # Verify Caddyfile exists
            if [ ! -f ${{ env.VPS_DEPLOY_PATH }}/Caddyfile ]; then
              echo "âŒ Caddyfile not found in deployment directory!"
              ls -la ${{ env.VPS_DEPLOY_PATH }}/
              exit 1
            else
              echo "âœ… Caddyfile found and ready"
            fi

  load-and-run:
    name: Load and Run Services with Docker Compose
    runs-on: ubuntu-latest
    environment: production
    needs: [transfer-image]
    steps:
      - name: Deploy with Docker Compose
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_PRIVATE_KEY }}
          port: 22
          script: |
            cd ${{ env.VPS_DEPLOY_PATH }}
            
            # Detect if sudo is needed for Docker commands
            USE_SUDO=""
            if ! docker ps &> /dev/null; then
              if sudo docker ps &> /dev/null; then
                echo "âš ï¸  Using sudo for Docker commands"
                USE_SUDO="sudo "
              else
                echo "âŒ Docker not accessible even with sudo"
                exit 1
              fi
            else
              echo "âœ… Docker accessible without sudo"
            fi
            
            # Create production .env file
            cat > .env.production << EOF
            # ===== GENERAL CONFIGURATION =====
            NODE_ENV=production
            NEXT_TELEMETRY_DISABLED=1
            
            # ===== APPLICATION =====
            NEXT_PUBLIC_APP_NAME="${{ secrets.NEXT_PUBLIC_APP_NAME }}"
            NEXT_PUBLIC_APP_VERSION="${{ secrets.NEXT_PUBLIC_APP_VERSION }}"
            
            # ===== DOMAINS & URLs =====
            FRONTEND_DOMAIN=${{ secrets.FRONTEND_DOMAIN }}
            NEXT_PUBLIC_API_URL=${{ secrets.NEXT_PUBLIC_API_URL }}
            NEXTAUTH_URL=${{ secrets.NEXTAUTH_URL }}
            
            # ===== SECURITY =====
            NEXTAUTH_SECRET=${{ secrets.NEXTAUTH_SECRET }}
            
            # ===== SSL/TLS =====
            ACME_EMAIL=${{ secrets.ACME_EMAIL }}
            
            # ===== API CONFIGURATION =====
            NEXT_PUBLIC_API_VERSION=${{ secrets.NEXT_PUBLIC_API_VERSION }}
            
            # ===== ANALYTICS & MONITORING =====
            NEXT_PUBLIC_ANALYTICS_ID=${{ secrets.NEXT_PUBLIC_ANALYTICS_ID }}
            NEXT_PUBLIC_GTM_ID=${{ secrets.NEXT_PUBLIC_GTM_ID }}
            NEXT_PUBLIC_SENTRY_DSN=${{ secrets.NEXT_PUBLIC_SENTRY_DSN }}
            
            # ===== FEATURES FLAGS =====
            NEXT_PUBLIC_ENABLE_FEATURES=${{ secrets.NEXT_PUBLIC_ENABLE_FEATURES }}
            
            # ===== CDN & ASSETS =====
            NEXT_PUBLIC_CDN_URL=${{ secrets.NEXT_PUBLIC_CDN_URL }}
            NEXT_PUBLIC_ASSETS_URL=${{ secrets.NEXT_PUBLIC_ASSETS_URL }}
            
            # ===== SOCIAL AUTH (Optional) =====
            GITHUB_CLIENT_ID=${{ secrets.GITHUB_CLIENT_ID }}
            GITHUB_CLIENT_SECRET=${{ secrets.GITHUB_CLIENT_SECRET }}
            GOOGLE_CLIENT_ID=${{ secrets.GOOGLE_CLIENT_ID }}
            GOOGLE_CLIENT_SECRET=${{ secrets.GOOGLE_CLIENT_SECRET }}
            
            # ===== PAYMENT (Optional) =====
            NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY=${{ secrets.NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY }}
            STRIPE_SECRET_KEY=${{ secrets.STRIPE_SECRET_KEY }}
            
            # ===== EMAIL (Optional) =====
            SMTP_HOST=${{ secrets.SMTP_HOST }}
            SMTP_PORT=${{ secrets.SMTP_PORT }}
            SMTP_USER=${{ secrets.SMTP_USER }}
            SMTP_PASSWORD=${{ secrets.SMTP_PASSWORD }}
            SMTP_FROM=${{ secrets.SMTP_FROM }}
            
            # ===== REDIS (Optional for caching) =====
            REDIS_URL=${{ secrets.REDIS_URL }}
            
            # ===== FEATURE FLAGS =====
            NEXT_PUBLIC_ENABLE_PWA=${{ secrets.NEXT_PUBLIC_ENABLE_PWA }}
            NEXT_PUBLIC_ENABLE_OFFLINE=${{ secrets.NEXT_PUBLIC_ENABLE_OFFLINE }}
            NEXT_PUBLIC_ENABLE_DARK_MODE=${{ secrets.NEXT_PUBLIC_ENABLE_DARK_MODE }}
            
            # ===== SEO & METADATA =====
            NEXT_PUBLIC_SITE_URL=${{ secrets.NEXT_PUBLIC_SITE_URL }}
            NEXT_PUBLIC_SITE_NAME="${{ secrets.NEXT_PUBLIC_SITE_NAME }}"
            NEXT_PUBLIC_SITE_DESCRIPTION="${{ secrets.NEXT_PUBLIC_SITE_DESCRIPTION }}"
            NEXT_PUBLIC_DEFAULT_LOCALE=${{ secrets.NEXT_PUBLIC_DEFAULT_LOCALE }}
            EOF
            
            # Create rexel-frontend-network if it doesn't exist
            if ! ${USE_SUDO}docker network ls | grep -q rexel-frontend-network; then
              echo 'Creating rexel-frontend-network...'
              ${USE_SUDO}docker network create rexel-frontend-network
            else
              echo 'rexel-frontend-network already exists'
            fi
            
            # Load the new Docker image
            ${USE_SUDO}docker load < images/rexel-frontend-prod-current.tar
            
            # Tag the loaded image as latest for docker-compose
            IMAGE_NAME=$(${USE_SUDO}docker images --format "table {{.Repository}}:{{.Tag}}" | grep rexel-frontend-prod | grep -v latest | head -n 1)
            ${USE_SUDO}docker tag $IMAGE_NAME rexel-frontend-prod:latest
            
            # Stop existing services
            echo 'Stopping existing services...'
            ${USE_SUDO}docker compose -f docker-compose.prod.yml down || echo 'No existing services to stop'
            
            # Start application service first
            echo 'Starting frontend application...'
            ${USE_SUDO}docker compose -f docker-compose.prod.yml up -d app
            
            # Wait for application to be ready
            echo "Waiting for frontend application to be ready..."
            max_attempts=30
            attempt=1
            while [ $attempt -le $max_attempts ]; do
              if ${USE_SUDO}docker ps -q -f name=${{ env.CONTAINER_NAME }} | grep -q .; then
                echo "Frontend container is running, checking health..."
                sleep 5
                # Try to connect to health endpoint
                if ${USE_SUDO}docker exec ${{ env.CONTAINER_NAME }} curl -f http://localhost:${{ env.CONTAINER_PORT }}/api/health > /dev/null 2>&1; then
                  echo "âœ… Frontend application is healthy!"
                  break
                else
                  echo "Frontend container running but health check failed (attempt $attempt/$max_attempts)"
                fi
              else
                echo "Frontend container not running yet (attempt $attempt/$max_attempts)"
              fi
              
              if [ $attempt -eq $max_attempts ]; then
                echo "âŒ Frontend application failed to start or become healthy"
                ${USE_SUDO}docker logs ${{ env.CONTAINER_NAME }}
                exit 1
              fi
              
              echo "Waiting 10 seconds before retry..."
              sleep 10
              attempt=$((attempt + 1))
            done
            
            # Start Caddy reverse proxy
            echo 'Starting Caddy reverse proxy...'
            
            # Verify Caddyfile before starting
            if [ ! -f Caddyfile ]; then
              echo "âŒ Caddyfile not found! Cannot start Caddy."
              ls -la .
              exit 1
            fi
            
            ${USE_SUDO}docker compose -f docker-compose.prod.yml up -d caddy
            
            # Wait for Caddy to start
            echo 'Waiting for Caddy to start...'
            sleep 15
            
            # Check if services are running
            echo 'Checking service status...'
            echo 'ðŸ“‹ Container Status:'
            ${USE_SUDO}docker ps -f name=rexel-frontend- --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
            
            # Check main containers
            app_running=$(${USE_SUDO}docker ps -q -f name=${{ env.CONTAINER_NAME }})
            caddy_running=$(${USE_SUDO}docker ps -q -f name=${{ env.CADDY_CONTAINER_NAME }})
            
            if [ ! -z "$app_running" ]; then
              echo 'âœ… Frontend application container is running!'
            else
              echo 'âŒ Frontend application container failed to start!'
              ${USE_SUDO}docker compose -f docker-compose.prod.yml logs app
              exit 1
            fi
            
            if [ ! -z "$caddy_running" ]; then
              echo 'âœ… Caddy reverse proxy is running!'
            else
              echo 'âš ï¸  Caddy container not running'
            fi
            
            echo 'Frontend deployment completed - services are running!'

  health-check:
    name: Final Health Check
    runs-on: ubuntu-latest
    environment: production
    needs: [load-and-run]
    if: always()
    steps:
      - name: Perform comprehensive health check
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_PRIVATE_KEY }}
          port: 22
          script: |
            cd ${{ env.VPS_DEPLOY_PATH }}
            
            # Detect if sudo is needed for Docker commands
            USE_SUDO=""
            if ! docker ps &> /dev/null; then
              if sudo docker ps &> /dev/null; then
                echo "âš ï¸  Using sudo for Docker commands"
                USE_SUDO="sudo "
              else
                echo "âŒ Docker not accessible even with sudo"
                exit 1
              fi
            fi
            
            echo "=== COMPREHENSIVE HEALTH CHECK ==="
            
            # Check container status
            echo "ðŸ“‹ Container Status:"
            ${USE_SUDO}docker ps -f name=rexel-frontend- --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
            
            # Check Caddy specifically
            echo -e "\nðŸŒ Caddy Reverse Proxy Status:"
            if [ $(${USE_SUDO}docker ps -q -f name=${{ env.CADDY_CONTAINER_NAME }}) ]; then
              echo "âœ… Caddy container is running"
              ${USE_SUDO}docker logs --tail=5 ${{ env.CADDY_CONTAINER_NAME }}
            else
              echo "âŒ Caddy container not running"
              echo "Available containers:"
              ${USE_SUDO}docker ps -a -f name=${{ env.CADDY_CONTAINER_NAME }}
            fi
            
            # Check application logs (last 10 lines)
            echo -e "\nðŸ“ Application Logs (last 10 lines):"
            ${USE_SUDO}docker compose -f docker-compose.prod.yml logs --tail=10 app
            
            # Test frontend health endpoint
            echo -e "\nðŸ©º Frontend Health Check:"
            if ${USE_SUDO}docker exec ${{ env.CONTAINER_NAME }} curl -f http://localhost:${{ env.CONTAINER_PORT }}/api/health > /dev/null 2>&1; then
              echo "âœ… Frontend health check successful"
              ${USE_SUDO}docker exec ${{ env.CONTAINER_NAME }} curl -s http://localhost:${{ env.CONTAINER_PORT }}/api/health | head -5
            else
              echo "âš ï¸  Frontend health check failed (services may still be starting)"
            fi
            
            # Check services status
            echo -e "\nðŸŒ Services Status:"
            app_running=$(${USE_SUDO}docker ps -q -f name=${{ env.CONTAINER_NAME }})
            caddy_running=$(${USE_SUDO}docker ps -q -f name=${{ env.CADDY_CONTAINER_NAME }})
            
            if [ ! -z "$app_running" ]; then
              echo "âœ… Frontend application container is running"
            else
              echo "âŒ Frontend application container not running"
            fi
            
            if [ ! -z "$caddy_running" ]; then
              echo "âœ… Caddy container is running"
            else
              echo "âŒ Caddy container not running"
            fi
            
            # Check disk space
            echo -e "\nðŸ’¾ Disk Space:"
            df -h ${{ env.VPS_DEPLOY_PATH }}
            
            echo -e "\n=== HEALTH CHECK COMPLETE ==="

  cleanup:
    name: Cleanup
    runs-on: ubuntu-latest
    environment: production
    needs: [load-and-run]
    if: always()
    steps:
      - name: Cleanup old Docker images and files
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_PRIVATE_KEY }}
          port: 22
          script: |
            # Detect if sudo is needed for Docker commands
            USE_SUDO=""
            if ! docker ps &> /dev/null; then
              if sudo docker ps &> /dev/null; then
                echo "âš ï¸  Using sudo for Docker commands"
                USE_SUDO="sudo "
              else
                echo "âŒ Docker not accessible even with sudo"
                exit 1
              fi
            fi
            
            # Remove dangling images
            ${USE_SUDO}docker image prune -f
            
            # Keep only the 3 most recent backup images
            cd ${{ env.VPS_DEPLOY_PATH }}/backups
            ls -t rexel-frontend-prod-backup-*.tar 2>/dev/null | tail -n +4 | xargs -r rm -f
            
            # Clean up old logs (keep last 7 days)
            find ${{ env.VPS_DEPLOY_PATH }} -name "*.log" -type f -mtime +7 -delete 2>/dev/null || true
            
            echo "âœ… Cleanup completed"

      - name: Deployment Summary
        run: |
          echo "## ðŸš€ Rexel Modern Frontend Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Setting | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|---------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| **Environment** | ${{ github.event.inputs.environment || 'production' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Repository** | ${{ github.repository }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Commit** | ${{ github.sha }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Rebuild Cache** | ${{ github.event.inputs.rebuild_cache || 'false' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Container** | ${{ env.CONTAINER_NAME }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Port** | ${{ env.CONTAINER_PORT }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Deploy Path** | ${{ env.VPS_DEPLOY_PATH }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ“‹ Services Deployed" >> $GITHUB_STEP_SUMMARY
          echo "- ðŸš€ **Rexel Frontend** (Next.js 15)" >> $GITHUB_STEP_SUMMARY
          echo "- ðŸŒ **Caddy Reverse Proxy** (Load Balancer & SSL)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ”— Next Steps" >> $GITHUB_STEP_SUMMARY
          echo "1. Verify frontend is responding correctly" >> $GITHUB_STEP_SUMMARY
          echo "2. Test API connectivity to backend" >> $GITHUB_STEP_SUMMARY
          echo "3. Check SSL certificate installation" >> $GITHUB_STEP_SUMMARY
          echo "4. Verify all features are working correctly" >> $GITHUB_STEP_SUMMARY 