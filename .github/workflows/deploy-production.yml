name: Deploy Frontend to Production

on:
  push:
    branches: [ main, master ]
      
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging
      rebuild_cache:
        description: 'Rebuild Next.js cache'
        required: true
        default: 'false'
        type: choice
        options:
          - 'true'
          - 'false'

env:
  DOCKER_IMAGE_NAME: kesimarket-frontend-prod
  VPS_DEPLOY_PATH: ~/kesimarket-modern/frontend
  CONTAINER_NAME: kesimarket-frontend-prod
  CONTAINER_PORT: 3000
  NETWORK_NAME: kesimarket-net

jobs:
  prepare-directory:
    name: Prepare VPS Directory
    runs-on: ubuntu-latest
    environment: production
    steps:
      - name: Create deployment directory on VPS
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_PRIVATE_KEY }}
          port: 22
          script: |
            mkdir -p ${{ env.VPS_DEPLOY_PATH }}
            mkdir -p ${{ env.VPS_DEPLOY_PATH }}/backups
            mkdir -p ${{ env.VPS_DEPLOY_PATH }}/images
            mkdir -p ${{ env.VPS_DEPLOY_PATH }}/data
            chmod 755 ${{ env.VPS_DEPLOY_PATH }}/data

  docker-setup:
    name: Verify Docker Setup and Network
    runs-on: ubuntu-latest
    environment: production
    steps:
      - name: Verify Docker environment and shared network
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_PRIVATE_KEY }}
          port: 22
          script: |
            echo "=== Docker Environment Check ==="
            
            # Check if Docker is installed
            if ! command -v docker &> /dev/null; then
              echo "üîß Docker not found, installing..."
              curl -fsSL https://get.docker.com -o get-docker.sh
              sudo sh get-docker.sh
              rm get-docker.sh
            else
              echo "‚úÖ Docker is installed: $(docker --version)"
            fi
            
            # Check if Docker service is running
            if ! sudo systemctl is-active --quiet docker; then
              echo "üîß Starting Docker service..."
              sudo systemctl start docker
              sudo systemctl enable docker
            else
              echo "‚úÖ Docker service is running"
            fi
            
            # Check if user is in docker group
            if ! groups $USER | grep -q '\bdocker\b'; then
              echo "üîß Adding user to docker group..."
              sudo usermod -aG docker $USER
              echo "‚ö†Ô∏è  User added to docker group. Testing access..."
            else
              echo "‚úÖ User is in docker group"
            fi
            
            # Test Docker access with retry logic
            echo "üß™ Testing Docker access..."
            max_attempts=5
            attempt=1
            
            while [ $attempt -le $max_attempts ]; do
              if docker ps &> /dev/null; then
                echo "‚úÖ Docker access test successful!"
                break
              else
                echo "‚ö†Ô∏è  Docker access test failed (attempt $attempt/$max_attempts)"
                if [ $attempt -eq $max_attempts ]; then
                  echo "‚ùå Docker access still failing after $max_attempts attempts"
                  echo "Trying with sudo as fallback..."
                  if sudo docker ps &> /dev/null; then
                    echo "‚úÖ Docker works with sudo"
                    echo "‚ö†Ô∏è  Will use sudo for Docker commands"
                  else
                    echo "‚ùå Docker not working even with sudo"
                    exit 1
                  fi
                else
                  echo "Waiting 5 seconds before retry..."
                  sleep 5
                  # Try to refresh group membership
                  newgrp docker || true
                fi
              fi
              attempt=$((attempt + 1))
            done
            
            # Install Docker Compose if not present
            if ! command -v docker-compose &> /dev/null && ! docker compose version &> /dev/null; then
              echo "üîß Installing Docker Compose..."
              sudo curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
              sudo chmod +x /usr/local/bin/docker-compose
            else
              echo "‚úÖ Docker Compose is available"
            fi
            
            # Check for shared network
            echo "üîó Checking shared Docker network..."
            if ! docker network ls | grep -q ${{ env.NETWORK_NAME }}; then
              echo "‚ö†Ô∏è  Shared network '${{ env.NETWORK_NAME }}' not found!"
              echo "Creating network '${{ env.NETWORK_NAME }}'..."
              docker network create ${{ env.NETWORK_NAME }}
              echo "‚úÖ Network '${{ env.NETWORK_NAME }}' created"
            else
              echo "‚úÖ Shared network '${{ env.NETWORK_NAME }}' exists"
            fi
            
            # Final verification
            echo "=== Final Docker Environment Status ==="
            docker --version || sudo docker --version
            docker compose version || docker-compose --version || sudo docker compose version
            echo "Docker daemon status: $(sudo systemctl is-active docker)"
            echo "User groups: $(groups $USER)"
            echo "Shared network: $(docker network ls | grep ${{ env.NETWORK_NAME }})"

  checkout:
    name: Checkout Code
    runs-on: ubuntu-latest
    needs: [docker-setup, prepare-directory]
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Upload source code
        uses: actions/upload-artifact@v4
        with:
          name: source-code
          path: .
          retention-days: 1

  build-docker:
    name: Build Docker Image
    runs-on: ubuntu-latest
    environment: production
    needs: [checkout]
    steps:
      - name: Download source code
        uses: actions/download-artifact@v4
        with:
          name: source-code
      
      - name: Create production .env file
        run: |
          if [ "${{ github.event.inputs.environment }}" = "staging" ]; then
            cat > .env.production << EOF
          # ===== ENVIRONMENT =====
          NODE_ENV=production
          NEXT_TELEMETRY_DISABLED=1
          
          # ===== APPLICATION =====
          NEXT_PUBLIC_APP_NAME="${{ secrets.NEXT_PUBLIC_APP_NAME }} (Staging)"
          NEXT_PUBLIC_APP_VERSION="${{ secrets.NEXT_PUBLIC_APP_VERSION }}-staging"
          
          # ===== STAGING DOMAINS & URLs =====
          NEXT_PUBLIC_API_URL=https://staging-api.kesimarket.com
          NEXTAUTH_URL=https://staging.kesimarket.com
          NEXT_PUBLIC_SITE_URL=https://staging.kesimarket.com
          
          # ===== SECURITY =====
          NEXTAUTH_SECRET=${{ secrets.NEXTAUTH_SECRET_STAGING }}
          
          # ===== SSL/TLS =====
          ACME_EMAIL=${{ secrets.ACME_EMAIL }}
          
          # ===== API CONFIGURATION =====
          NEXT_PUBLIC_API_VERSION=${{ secrets.NEXT_PUBLIC_API_VERSION }}
          
          # ===== FEATURES FLAGS =====
          NEXT_PUBLIC_ENABLE_FEATURES=${{ secrets.NEXT_PUBLIC_ENABLE_FEATURES }}
          
          # ===== CDN & ASSETS =====
          NEXT_PUBLIC_CDN_URL=https://staging-cdn.kesimarket.com
          NEXT_PUBLIC_ASSETS_URL=https://staging-assets.kesimarket.com
          
          # ===== FEATURE FLAGS =====
          NEXT_PUBLIC_ENABLE_PWA=${{ secrets.NEXT_PUBLIC_ENABLE_PWA }}
          NEXT_PUBLIC_ENABLE_OFFLINE=${{ secrets.NEXT_PUBLIC_ENABLE_OFFLINE }}
          NEXT_PUBLIC_ENABLE_DARK_MODE=${{ secrets.NEXT_PUBLIC_ENABLE_DARK_MODE }}
          
          # ===== SEO & METADATA =====
          NEXT_PUBLIC_SITE_NAME="${{ secrets.NEXT_PUBLIC_SITE_NAME }} (Staging)"
          NEXT_PUBLIC_SITE_DESCRIPTION="${{ secrets.NEXT_PUBLIC_SITE_DESCRIPTION }}"
          NEXT_PUBLIC_DEFAULT_LOCALE=${{ secrets.NEXT_PUBLIC_DEFAULT_LOCALE }}
          
          # ===== STAGING SPECIFIC =====
          NEXT_PUBLIC_DEBUG_MODE=true
          NEXT_PUBLIC_SHOW_STAGING_BANNER=true
          EOF
          else
            cat > .env.production << EOF
          # ===== ENVIRONMENT =====
          NODE_ENV=production
          NEXT_TELEMETRY_DISABLED=1
          
          # ===== APPLICATION =====
          NEXT_PUBLIC_APP_NAME="${{ secrets.NEXT_PUBLIC_APP_NAME }}"
          NEXT_PUBLIC_APP_VERSION="${{ secrets.NEXT_PUBLIC_APP_VERSION }}"
          
          # ===== PRODUCTION DOMAINS & URLs =====
          NEXT_PUBLIC_API_URL=https://api.kesimarket.com
          NEXTAUTH_URL=https://kesimarket.com
          NEXT_PUBLIC_SITE_URL=https://kesimarket.com
          
          # ===== SECURITY =====
          NEXTAUTH_SECRET=${{ secrets.NEXTAUTH_SECRET }}
          
          # ===== SSL/TLS =====
          ACME_EMAIL=${{ secrets.ACME_EMAIL }}
          
          # ===== API CONFIGURATION =====
          NEXT_PUBLIC_API_VERSION=${{ secrets.NEXT_PUBLIC_API_VERSION }}
          
          # ===== ANALYTICS & MONITORING =====
          NEXT_PUBLIC_ANALYTICS_ID=${{ secrets.NEXT_PUBLIC_ANALYTICS_ID }}
          NEXT_PUBLIC_GTM_ID=${{ secrets.NEXT_PUBLIC_GTM_ID }}
          NEXT_PUBLIC_SENTRY_DSN=${{ secrets.NEXT_PUBLIC_SENTRY_DSN }}
          
          # ===== FEATURES FLAGS =====
          NEXT_PUBLIC_ENABLE_FEATURES=${{ secrets.NEXT_PUBLIC_ENABLE_FEATURES }}
          
          # ===== CDN & ASSETS =====
          NEXT_PUBLIC_CDN_URL=https://cdn.kesimarket.com
          NEXT_PUBLIC_ASSETS_URL=https://assets.kesimarket.com
          
          # ===== SOCIAL AUTH (Optional) =====
          GITHUB_CLIENT_ID=${{ secrets.GITHUB_CLIENT_ID }}
          GITHUB_CLIENT_SECRET=${{ secrets.GITHUB_CLIENT_SECRET }}
          GOOGLE_CLIENT_ID=${{ secrets.GOOGLE_CLIENT_ID }}
          GOOGLE_CLIENT_SECRET=${{ secrets.GOOGLE_CLIENT_SECRET }}
          
          # ===== PAYMENT (Optional) =====
          NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY=${{ secrets.NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY }}
          STRIPE_SECRET_KEY=${{ secrets.STRIPE_SECRET_KEY }}
          
          # ===== EMAIL (Optional) =====
          SMTP_HOST=${{ secrets.SMTP_HOST }}
          SMTP_PORT=${{ secrets.SMTP_PORT }}
          SMTP_USER=${{ secrets.SMTP_USER }}
          SMTP_PASSWORD=${{ secrets.SMTP_PASSWORD }}
          SMTP_FROM=${{ secrets.SMTP_FROM }}
          
          # ===== REDIS (Optional for caching) =====
          REDIS_URL=${{ secrets.REDIS_URL }}
          
          # ===== FEATURE FLAGS =====
          NEXT_PUBLIC_ENABLE_PWA=${{ secrets.NEXT_PUBLIC_ENABLE_PWA }}
          NEXT_PUBLIC_ENABLE_OFFLINE=${{ secrets.NEXT_PUBLIC_ENABLE_OFFLINE }}
          NEXT_PUBLIC_ENABLE_DARK_MODE=${{ secrets.NEXT_PUBLIC_ENABLE_DARK_MODE }}
          
          # ===== SEO & METADATA =====
          NEXT_PUBLIC_SITE_NAME="${{ secrets.NEXT_PUBLIC_SITE_NAME }}"
          NEXT_PUBLIC_SITE_DESCRIPTION="${{ secrets.NEXT_PUBLIC_SITE_DESCRIPTION }}"
          NEXT_PUBLIC_DEFAULT_LOCALE=${{ secrets.NEXT_PUBLIC_DEFAULT_LOCALE }}
          EOF
          fi
      
      - name: Verify .env file created
        run: |
          echo "Checking if .env.production file exists..."
          ls -la .env.production
          echo "Environment variables count:"
          wc -l .env.production
      
      - name: Generate image tag
        id: tag
        run: |
          SHORT_SHA=$(echo ${{ github.sha }} | cut -c1-7)
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          IMAGE_TAG="${{ env.DOCKER_IMAGE_NAME }}:${SHORT_SHA}-${TIMESTAMP}"
          echo "image-tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "short-sha=${SHORT_SHA}" >> $GITHUB_OUTPUT
          echo "timestamp=${TIMESTAMP}" >> $GITHUB_OUTPUT
      
      - name: Build Docker image
        run: |
          docker build -t ${{ steps.tag.outputs.image-tag }} .
          docker tag ${{ steps.tag.outputs.image-tag }} ${{ env.DOCKER_IMAGE_NAME }}:latest
      
      - name: Save Docker image to tar
        run: |
          docker save ${{ steps.tag.outputs.image-tag }} > kesimarket-frontend-prod.tar
          ls -lh kesimarket-frontend-prod.tar

      - name: Upload Docker image and compose file
        uses: actions/upload-artifact@v4
        with:
          name: docker-image-prod
          path: |
            kesimarket-frontend-prod.tar
            docker-compose.prod.yml
          retention-days: 7

  transfer-image:
    name: Transfer Image to VPS
    runs-on: ubuntu-latest
    environment: production
    needs: [prepare-directory, build-docker]
    steps:
      - name: Download Docker image
        uses: actions/download-artifact@v4
        with:
          name: docker-image-prod
      
      - name: Transfer Docker image and compose files to VPS
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_PRIVATE_KEY }}
          port: 22
          source: "kesimarket-frontend-prod.tar,docker-compose.prod.yml"
          target: ${{ env.VPS_DEPLOY_PATH }}/
      
      - name: Create backup and organize files
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_PRIVATE_KEY }}
          port: 22
          script: |
            # Create images directory if it doesn't exist
            mkdir -p ${{ env.VPS_DEPLOY_PATH }}/images
            
            # Backup previous image if exists
            if [ -f ${{ env.VPS_DEPLOY_PATH }}/images/kesimarket-frontend-prod-current.tar ]; then
              mv ${{ env.VPS_DEPLOY_PATH }}/images/kesimarket-frontend-prod-current.tar ${{ env.VPS_DEPLOY_PATH }}/backups/kesimarket-frontend-prod-backup-$(date +%Y%m%d-%H%M%S).tar
            fi
            
            # Move new image to images directory
            mv ${{ env.VPS_DEPLOY_PATH }}/kesimarket-frontend-prod.tar ${{ env.VPS_DEPLOY_PATH }}/images/kesimarket-frontend-prod-current.tar
            
            echo "‚úÖ Files organized and ready for deployment"

  load-and-run:
    name: Load and Run Frontend Service
    runs-on: ubuntu-latest
    environment: production
    needs: [transfer-image]
    steps:
      - name: Deploy Frontend with Docker Compose
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_PRIVATE_KEY }}
          port: 22
          script: |
            cd ${{ env.VPS_DEPLOY_PATH }}
            
            # Detect if sudo is needed for Docker commands
            USE_SUDO=""
            if ! docker ps &> /dev/null; then
              if sudo docker ps &> /dev/null; then
                echo "‚ö†Ô∏è  Using sudo for Docker commands"
                USE_SUDO="sudo "
              else
                echo "‚ùå Docker not accessible even with sudo"
                exit 1
              fi
            else
              echo "‚úÖ Docker accessible without sudo"
            fi
            
            # Verify shared network exists
            if ! ${USE_SUDO}docker network ls | grep -q ${{ env.NETWORK_NAME }}; then
              echo "‚ùå Shared network '${{ env.NETWORK_NAME }}' not found!"
              echo "Please ensure the backend is deployed first or run the network setup script."
              echo "Creating network as fallback..."
              ${USE_SUDO}docker network create ${{ env.NETWORK_NAME }}
            else
              echo "‚úÖ Shared network '${{ env.NETWORK_NAME }}' exists"
            fi
            
            # Load the new Docker image
            ${USE_SUDO}docker load < images/kesimarket-frontend-prod-current.tar
            
            # Tag the loaded image as latest for docker-compose
            IMAGE_NAME=$(${USE_SUDO}docker images --format "table {{.Repository}}:{{.Tag}}" | grep kesimarket-frontend-prod | grep -v latest | head -n 1)
            ${USE_SUDO}docker tag $IMAGE_NAME kesimarket-frontend-prod:latest
            
            # Stop existing frontend service
            echo 'Stopping existing frontend service...'
            ${USE_SUDO}docker compose -f docker-compose.prod.yml down || echo 'No existing services to stop'
            
            # Start frontend application
            echo 'Starting frontend application...'
            ${USE_SUDO}docker compose -f docker-compose.prod.yml up -d frontend
            
            echo 'Frontend deployment completed - service is running!'

  cleanup:
    name: Cleanup
    runs-on: ubuntu-latest
    environment: production
    needs: [load-and-run]
    if: always()
    steps:
      - name: Cleanup old Docker images and files
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_PRIVATE_KEY }}
          port: 22
          script: |
            # Detect if sudo is needed for Docker commands
            USE_SUDO=""
            if ! docker ps &> /dev/null; then
              if sudo docker ps &> /dev/null; then
                echo "‚ö†Ô∏è  Using sudo for Docker commands"
                USE_SUDO="sudo "
              else
                echo "‚ùå Docker not accessible even with sudo"
                exit 1
              fi
            fi
            
            # Remove dangling images
            ${USE_SUDO}docker image prune -f
            
            # Keep only the 3 most recent backup images
            cd ${{ env.VPS_DEPLOY_PATH }}/backups
            ls -t kesimarket-frontend-prod-backup-*.tar 2>/dev/null | tail -n +4 | xargs -r rm -f
            
            echo "‚úÖ Cleanup completed"

      - name: Deployment Summary
        run: |
          echo "## üöÄ KesiMarket Modern Frontend Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Setting | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|---------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| **Environment** | ${{ github.event.inputs.environment || 'production' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Repository** | ${{ github.repository }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Commit** | ${{ github.sha }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Docker Image** | ${{ env.DOCKER_IMAGE_NAME }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Network** | ${{ env.NETWORK_NAME }} (shared) |" >> $GITHUB_STEP_SUMMARY
          echo "| **Container** | ${{ env.CONTAINER_NAME }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ "${{ github.event.inputs.environment }}" = "staging" ]; then
            echo "üåê **Staging URLs:** " >> $GITHUB_STEP_SUMMARY
            echo "- Frontend: https://staging.kesimarket.com" >> $GITHUB_STEP_SUMMARY
            echo "- API: https://staging-api.kesimarket.com" >> $GITHUB_STEP_SUMMARY
          else
            echo "üåê **Production URLs:** " >> $GITHUB_STEP_SUMMARY
            echo "- Frontend: https://kesimarket.com" >> $GITHUB_STEP_SUMMARY
            echo "- API: https://api.kesimarket.com" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "‚ÑπÔ∏è **Note:** Reverse proxy managed by backend deployment" >> $GITHUB_STEP_SUMMARY 